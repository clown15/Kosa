## Go
### 상수
상수는 선언만 하는것을 불가능 하고 초기화까지 해야 한다.   
타입 미지정 상수는 리터럴과 같은 취급   
타입 지정 상수는 해당 타입 변수에만 항당해야 함   

### 사용하지 않는 변수
지역 변수는 반드시 사용되어야 한다.   
사용되지 않는 상수는 허용 한다. 즉 선언 과 초기화만 해도 문제 없다.

### 변수와 상수 이름 짓기

    유니코드 문자를 식별자로 허용하지만 권장하진 않는다.
    관용적으로 스네이크 표기법을 사용하지 않는다.(낙타 표기법, 파스칼 표기법 사용)
        스네이크 표기법
            단어 사이에 _를 활용하는 기법
        낙타 표기법
            소문자로 시작하고 이어지는 단어들의 시작은 대문자로 작성하여 단어 간 구분에 용이한 표기법
        파스칼 표기법
            단어의 첫 시작은 항상 대문자를 사용하는 표기법
    Go는 일반 상수 이름 규칙을 따르지 않는다.
    패키지에 포함된 요소를 외부에 노출(expose) 여부를 식별자의 첫 글자가 대소문자 여부로 결정
        대문자로 시작하면 함수
    함수 내에서는 짧은 변수 이름 선호
        변수의 의미보다 간결성을 선호
    짧은 이름
        코드 간결
        코드의 복잡도 판별 기준
    패키지 블록 내
        설명적인 변수, 상수 이름 사용 권장

### 복합 타입
#### 배열
같은 타입의 여러 데이터를 담는다.   
시퀀스 타입(순서 중요)   
Go에서는 선호하지 않는다.(특별한 경우에만 사용)   
선언 시 크기를 지정해야 한다.   
크기 변경 불가   
배열 간 비교 가능   
배열 인뎃스는 범위를 벗어나서는 안되고 음수도 불가   

    선언 방법   
    var name [size] type 형태로 선언
    제로 값으로 선언
        배열의 크기와 배열 내 요소 타입 지정
        var a [3]int
    배열 초기값 지정
        배열 리터럴 사용
        var a = [3]int{10, 20, 30}
    희소 배열
        대부분의 요소가 0인 배열
        var a = [12]int{1, 5: 4, 6, 10: 100, 15}
        [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]
    배열 크기 지정X
        배열 리터럴 필요
        var a = [...]int{10, 20, 30}
    다차원 배열
        []의 개수가 차원 수
        var a [2][3]int

    배열 요소 접근
        [index] 사용
    배열 길이
        len(array) 함수
    배열을 잘 사용하지 않는 이유
        배열의 크기가 배열의 타입을 결정하는데 사용된다
        즉 원소의 타입이 같은 배열이라도 크기가 다르면 다른 타입
        크기(길이)가 다르면 타입 변환도 불가능하다.
        이러한 이유들로 정확히 필요한 크기를 아는 경우가 아니라면 배열을 사용하지 않는다.

### 슬라이스
일련의 값(시퀀스)을 저장하는 자료 구조 - 순서 중요
슬라이스의 크기는 타입의 일부가 아니다.(배열과 차이점)
슬라이스 간 비교는 불가(단 nil과는 비교 가능)

슬라이스 선언

    슬라이스 선언시 크기 지정 필요 없다
    슬라이스 초기값 지정
        슬라이스 리터럴
        var a = []int{10, 20, 30}
        a := []int{10, 20, 30}
        배열에서 [...]했던것과 다르다.
    희소 슬라이스
        var a = []int{1, 5: 4, 6, 10: 100, 15}
        [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]
    다차원 슬라이스
        var a = [][]int{{1, 2}, {4, 5, 6}}
        var a [][]int
        둘다 사용 가능하다.
    제로 슬라이스
        슬라이스 리터럴 없이 선언만 하는 것
        슬라이스의 제로 값은 nil
            nil : 값의 부재(absence of value) 상태
        var a []int
        a == nil -> true
    비어있는 슬라이스
        초기값이 없는 슬라이스
        var a = []int()
        a == nil -> false

길이
>배열 과 마찬가지로 len(slice) 사용

값 추가
>append() 사용   
a = append(a, 10)   
해당 슬라이스를 변환하는 것이 아닌 복사본을 반환한다.   

수용력
>예약된(미리 준비된) 연속적인 메모리 공간의 크기   
수용력 >= 길이   
요소가 추가되면 길이는 커지고 결국 수용력과 같아진다.   
길이와 수용력이 같은 상태에서 요소가 추가되면 Go 런타임이 더 큰 수용력을 가지는 새로운 슬라이스를 할당, 원본 슬라이스의 값들은 새 슬라이스에 복사된다. 추가된 값은 새 슬라이스에 append되고 이 새 슬라이스가 반환된다. 즉 슬라이스의 크기가 수용력보다 작으면 같은 주소를 사용하고 슬라이스의 크기가 수용력과 같아 확장이 필요하면 주소 값이 변경된다.   
이전에 사용된 메모리는 가비지 컬렉터에 의해 정리되고 수용력 증가시 이전 수용력이 1024 보다 작으면 두배, 크면 25%씩 증가한다.   

make()

    슬라이스에 저장될 요소 개수를 미리 알 수 있다면 make()를 사용해 효율적인 슬라이스 작업을 도모할 수 있다.
    a := make([]int, 5)
        길이와 수용력이 5이며 모두 0으로 초기화된 슬라이스 생성
    a := make([]int, 길이, 수용력)
        길이와 수용력을 지정해 생성하며 길이만큼 0으로 초기화 되어 생성된다.

슬라이스의 슬라이싱

    슬라이스 연산자 (:)
    슬라이스로 부터 슬라이스 생성(python의 슬라이싱과 비슷)
    슬라이스 연산자를 사용하면 복사를 만들지 않고 메모리를 공유한다.
    슬라이싱과 append를 함께 사용하면 혼란이 생길 수 있다.
    하위 슬라이스의 수용력은 원본 슬라이스 수용력 - 하위 슬라이스 시작 오프셋

슬라이싱 append 혼합 사용 예시
```
x := []int{1, 2, 3, 4}   
y := x[:2]   

y = append(y, 1)   
fmt.Println("x:", x)   
fmt.Println("y:", y)   
x : [1 2 1 4]   
y : [1 2 1]   

y = append(y, 10, 20, 30)   
fmt.Println("x:", x)   
fmt.Println("y:", y)   
x : [1 2 1 4]   
y : [1 2 1 10 20 30]   
```
이러한 혼란을 완전한 슬라이스 표현식으로 해결   
하위 슬라이스에 얼마나 많은 메모리를 공유할지 지정   
슬라이스 연산때 : 을 한 번 더 사용하여 세번째 인자에 원본 슬라이스에서 하위 슬라이스에 공유할 마지막 원소의 위치 지정   
위 방법을 통해 append에 대해서는 해결 되지만 인덱스의 값을 변경하면 여전히 연결 되어있다.   

배열을 슬라이스로 변환
>배열에 슬라이스 연산 적용   
메모리 공유 문제 존재

슬라이스 복제
>원본 슬라이스로 부터 독립된 슬라이스 생성시 사용   
copy(타겟슬라이스, 원본슬라이스)   
타겟 슬라이스 크기만큼 복사되며 복사된 요소의 개수를 반환한다. 반환값이 필요 없으면 저장하지 않으면 된다.   

### 문자열과 룬(rune) 그리고 바이트
문자열은 룬으로 이루어진 것은 아니다.   
문자열은 바이트의 시퀀스이다.   
문자열의 길이는 바이트 수   
문자열에 슬라이스 연산 사용 가능   
>문자열은 수정불가이기 때문에 슬라이스의 메모리 공유 문제가 없다.   
유니코드로 구성되기 때문에 슬라이스를 했을 때 문자가 깨질 수 있다.(한글 3byte)   

문자열은 바이트 슬라이스 또는 룬 슬라이스로 변환 가능

### 맵
순서 없는 데이터 처리 유용   
(Key, Value) Pair   
var 변수명 map[키타입]값타입   

생성

    제로 값 할당
        map의 제로 값은 nil
        nil 맵의 값을 읽으면 맵 값이 되는 타입의 제로 값
        변수명 := map[키타입]값타입{}
    맵 리터럴
        비어 있는 맵 생성
        nil 맵과는 다르다.
    값이 있는 맵 리터럴
        키와 값을 콜론으로 구분
        마지막 요소(키, 값)의 끝에 콤마를 붙인다.
    make() 함수로 생성
        맵의 요소 개수를 알때 사용
        길이는 0 (make()로 슬라이스 만드는 것과 다르다)
        초기 지정 개수 이상으로 커질 수 있다.
        맵의 제로 값은 nil

맵은 비교 불가능, 단 nil과 같은지 다른지는 비교 가능

맵 읽고 쓰기

    새로운 키,값을 만들때 := 연산자는 사용 불가 = 을 사용하면 된다.
    아직 설정되지 않은 키에 할당된 값을 읽으면 값 타입의 제로 값이 반환된다.

콤마 OK 관용구(idiom)

    맵의 키에 대응되는 값이 없어도 제로 값이 리턴된다
    맵에 키가 존재하는지 확인할 필요가 있을 때 주로 사용하는 패턴
    맵에 키가 없어서 제로 값이 반환되는지
    실제로 키가 있는데 해당 값이 제로인 건지
    v, ok := map[key]
        v에는 해당 키의 값이
        ok에는 있는 키인지 true/false 반환

맵 삭제
    delete(map,key) 함수를 통해 요소 삭제
    키가 존재하지 않거나 nil 맵인 경우 아무것도 일어나지 않음
    delete() 함수는 반환값이 없음

맵을 셋(집합)으로 이용
    값이 유니크하며 순서가 없다.
    Go는 집합형을 직접 지원하지 않고 맵을 통해 간접적으로 지원
    집합의 원소로 쓰고 싶은 타입을 맵의 키 타입으로
    맵의 값을 불리언으로 설정

```
intSet := map[int]bool{}
vals := []int{5, 10, 2, 5, 8, 7, 3, 9, 1, 2, 10}
for _, v := range vals {
    intSet[v] = true
}


intSet[1:true 2:true 3:true 5:true 7:true 8:true 9:true 10:true]
```

### 구조체
여러 데이터 타입을 한데 묶어서 다루고 싶을 때 사용   
type 구조체 이름 struct {} 형태로 선언   
구조체는 사용자 정의 타입    
따라서 바로 사용할 수 없다.   
>구조체 정의 -> 구조체를 타입으로 하는 변수 선언   

구조체 항목들은 콤마로 구분하지 않는다.   

선언

    구조체 선언
        type person struct {
            name string
            age int
        }
    
    구조체 사용
        제로 구조체와 비어있는 구조체는 같다.
        var fred person
        구조체 리터럴 선언
        fred := person{
            “fred”,
            40,
        }
        fred := person{
            name: “fred”,
        }
두 가지 방식으로 선언 가능하며 항목을 지정하지 않으면 모든 항목에 대해 값을 지정하고 순서에 맞게 지정해야 한다.

#### 익명 구조체
변수를 구조체 타입 이름을 지정하지 않고 구조체 타입을 구현하여 선언   
한 번만 사용할 구조체   
type대신 var를 사용한다.   

선언

```
var person struct {
    name string
    age int
}
person.name = “bob”
person.age = 50


pet := struct{
    name string
    kind string
}{
    name : “Fido”,
    kind : “dog”,
}
```

주요 용도

    마샬링, 언마샬링
        외부 데이터를 구조체로 전환/ 구조체를 외부 데이터로 전환
    테스트 작성

구조체 비교와 변환

    구조체 비료는 항목에 따라 다름
    두 개의 구조체가 같은 이름, 순서, 타입으로 구성되어 있으면 구조체 간에 타입 변환 가능
